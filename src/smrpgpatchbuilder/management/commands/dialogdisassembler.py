from django.core.management.base import BaseCommand
from randomizer.management.disassembler_common import shortify, bit, dbyte, hbyte, named, con, byte, byte_int, short, short_int, writeline, writeline_dialog
from randomizer.data.dialogs import decompress

banks = [
    {
        "id": 0x22,
        "start": 0x220000,
        "end": 0x22FD17,
        "table_size": 0x08,
        "pointers": {
            "start": 0x37E000,
            "end": 0x37EFFF
        }
    },
    {
        "id": 0x23,
        "start": 0x230000,
        "end": 0x23F2D4,
        "table_size": 0x04,
        "pointers": {
            "start": 0x37F000,
            "end": 0x37F7FF
        }
    },
    {
        "id": 0x24,
        "start": 0x240000,
        "end": 0x248FFF,
        "table_size": 0x04,
        "pointers": {
            "start": 0x37F800,
            "end": 0x37FFFF
        }
    },
]

class Command(BaseCommand):

    def add_arguments(self, parser):
        parser.add_argument('-r', '--rom', dest='rom',
                            help='Path to a Mario RPG rom')

        parser.add_argument('-d', '--debug', action="store_true",
                            help='If set, dumps to a gitignored folder instead of overwriting the scripts sourced by SMRPG Randomizer')

    
    def handle(self, *args, **options):
        debug = options['debug']

        dest = 'randomizer/data/dialog_data'
        if debug:
            dest = 'randomizer/management/commands/output/disassembler/dialogs'

        global rom
        rom = bytearray(open(options['rom'], 'rb').read())

        pointers = []
        pointers_relative = []

        # get # of pointers
        for bank in banks:
            bank_id = bank["id"]
            ptrstart = bank["pointers"]["start"]
            ptrend = bank["pointers"]["end"]
            tblsize = bank["table_size"]
            start = bank["start"]
            end = bank["end"]

            bank_pointers = []

            #get pointers
            for i in range(0, (ptrend - ptrstart + 1) // 2):
                if i >= 0x600:
                    pointer = (bank_id << 16) + shortify(rom, start + 6) + (shortify(rom, ptrstart + i * 2))
                elif i >= 0x400:
                    pointer = (bank_id << 16) + shortify(rom, start + 4) + (shortify(rom, ptrstart + i * 2))
                elif i >= 0x200:
                    pointer = (bank_id << 16) + shortify(rom, start + 2) + (shortify(rom, ptrstart + i * 2))
                else:
                    pointer = (bank_id << 16) + shortify(rom, start) + (shortify(rom, ptrstart + i * 2))
                if (pointer > end):
                    pointer = bank_pointers[i - 1]
                bank_pointers.append(pointer)
            pointers += bank_pointers
        
        # will store info about positions in each string that the pointers are intended to point to
        # so that changing the strings can make sure the pointers are still going to the right place in the dialog data
        pointers_relative = [None]*len(pointers)

        #for i in range(len(pointers)):
        #    p = pointers[i]
        #    print(hex(i), hex(p))

        for bank in banks:
            raw_data = []
            bank_id = bank["id"]
        
            file = open("%s/dialog_table_0x%02x.py" % (dest, bank_id), "wb")
            file.write('# AUTOGENERATED DO NOT EDIT!!\n'.encode("utf8"))
            file.write('# Run the following command if you need to rebuild the table\n'.encode("utf8"))
            file.write('# python manage.py dialoguedisassembler --rom ROM\n'.encode("utf8"))

            ptrstart = bank["pointers"]["start"]
            ptrend = bank["pointers"]["end"]
            tblsize = bank["table_size"]
            start = bank["start"]
            end = bank["end"]

            def note_pointer(cursor, string):
                if (cursor in pointers):
                    indices = [i for i, x in enumerate(pointers) if x == cursor]
                    for match_pointer_index in indices:
                        pointers_relative[match_pointer_index] = {
                            "bank": bank_id,
                            "index": len(raw_data),
                            "pos": len(string)
                        } # only thing to be careful about here is that "position" may be confusing when referencing decompressed dialog
    
            # get dialog data
            cursor = start + tblsize
            string = bytearray([])
            while cursor <= end: 
                note_pointer(cursor, string)
                string.append(rom[cursor])
                if rom[cursor] in [0x1C, 0x0B, 0x0D]:
                    cursor += 1
                    note_pointer(cursor, string)
                    string.append(rom[cursor])
                elif rom[cursor] in [0x00, 0x06]: # do NOT terminate if they immediately follow 1C, 0B, or 0D
                    raw_data.append(string)
                    string = bytearray([])
                cursor += 1
            if len(string) > 0:
                raw_data.append(string)

            file.write(('dialog_data = [None]*%i\n' % len(raw_data)).encode("utf8"))

            for i in range(len(raw_data)):
                s = decompress(raw_data[i])
                file.write(("dialog_data[%i] = '''%s'''\n" % (i, s)).encode("utf8"))
                # why do the pointers reset at 0x400???
            
            file.close()
            
        file = open("%s/dialog_pointers.py" % dest, "wb")
        file.write('# AUTOGENERATED DO NOT EDIT!!\n'.encode("utf8"))
        file.write('# Run the following command if you need to rebuild the table\n'.encode("utf8"))
        file.write('# python manage.py dialoguedisassembler --rom ROM\n'.encode("utf8"))
        file.write(('pointers = [None]*%i\n' % len(pointers_relative)).encode("utf8"))
        for i in range(len(pointers_relative)):
            ptr = pointers_relative[i]
            if ptr is not None:
                # print(hex(pointers[i]), ptr)
                file.write(('pointers[%i] = {"bank": 0x%02x, "index": %i, "pos": %i}\n' % (i, ptr["bank"], ptr["index"], ptr["pos"])).encode("utf8"))
        file.close()

